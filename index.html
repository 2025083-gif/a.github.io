<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Puyo Tetris Fusion Canvas</title>
    <style>
        body {
            background: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            margin-top: 20px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border: 4px solid #444;
        }
        canvas {
            display: block;
            background: #000;
        }
        .ui {
            position: absolute;
            top: 10px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            pointer-events: none;
            text-shadow: 2px 2px 4px #000;
        }
        .stats { font-size: 20px; font-weight: bold; color: #0f0; }
        .controls-hint {
            margin-top: 15px;
            color: #888;
            text-align: center;
            line-height: 1.6;
        }
        .label { color: #fff; font-size: 14px; text-transform: uppercase; letter-spacing: 2px; }
    </style>
</head>
<body>

    <div id="game-container">
        <div class="ui">
            <div><span class="label">Tetris</span></div>
            <div class="stats">SCORE: <span id="score">0</span></div>
            <div><span class="label">PuyoPuyo</span></div>
        </div>
        <canvas id="gameCanvas" width="600" height="600"></canvas>
    </div>

    <div class="controls-hint">
        <b>[TETRIS]</b> Left/Right/Down: Move, Up: Rotate <br>
        <b>[PUYO]</b> A/S/D: Move, W: Rotate
    </div>

<script>
/**
 * 定数・設定
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');

const ROWS = 20;
const COLS = 10; // 各エリアの横幅
const BLOCK_SIZE = 30;
const CANVAS_WIDTH = 600;
const CANVAS_HEIGHT = 600;

let score = 0;
let particles = [];

// 色定義
const TETRIS_COLORS = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
const PUYO_COLORS = [null, '#ff4d4d', '#4dff4d', '#4d4dff', '#ffff4d']; // 赤, 緑, 青, 黄

/**
 * 共通処理: 行列生成
 */
function createMatrix(w, h) {
    const matrix = [];
    while (h--) matrix.push(new Array(w).fill(0));
    return matrix;
}

/**
 * --- テトリス ロジック ---
 */
const tetrisBoard = createMatrix(COLS, ROWS);
const tetrisPlayer = {
    pos: {x: 3, y: 0},
    matrix: null,
};

function createPiece(type) {
    if (type === 'I') return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
    if (type === 'L') return [[0,2,0],[0,2,0],[0,2,2]];
    if (type === 'J') return [[0,3,0],[0,3,0],[3,3,0]];
    if (type === 'O') return [[4,4],[4,4]];
    if (type === 'Z') return [[5,5,0],[0,5,5],[0,0,0]];
    if (type === 'S') return [[0,6,6],[6,6,0],[0,0,0]];
    if (type === 'T') return [[0,7,0],[7,7,0],[0,7,0]];
}

function tetrisRotate(dir) {
    const m = tetrisPlayer.matrix;
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
        }
    }
    if (dir > 0) m.forEach(row => row.reverse());
    else m.reverse();
}

function tetrisCollide() {
    const [m, o] = [tetrisPlayer.matrix, tetrisPlayer.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && (tetrisBoard[y + o.y] && tetrisBoard[y + o.y][x + o.x]) !== 0) return true;
        }
    }
    return false;
}

function tetrisMerge() {
    tetrisPlayer.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) tetrisBoard[y + tetrisPlayer.pos.y][x + tetrisPlayer.pos.x] = value;
        });
    });
}

function tetrisSweep() {
    let rowCount = 1;
    outer: for (let y = ROWS - 1; y > 0; --y) {
        for (let x = 0; x < COLS; ++x) {
            if (tetrisBoard[y][x] === 0) continue outer;
        }
        const row = tetrisBoard.splice(y, 1)[0].fill(0);
        tetrisBoard.unshift(row);
        ++y;
        score += rowCount * 100;
        rowCount *= 2;
        spawnExplosion(150, y * BLOCK_SIZE, '#fff');
    }
}

function tetrisReset() {
    const pieces = 'ILJOTSZ';
    tetrisPlayer.matrix = createPiece(pieces[Math.random() * pieces.length | 0]);
    tetrisPlayer.pos.y = 0;
    tetrisPlayer.pos.x = 3;
    if (tetrisCollide()) {
        tetrisBoard.forEach(row => row.fill(0));
        score = 0;
    }
}

/**
 * --- ぷよぷよ ロジック ---
 */
const puyoBoard = createMatrix(COLS, ROWS);
const puyoPlayer = {
    pos: {x: 4, y: 1},
    colors: [1, 2], 
    rot: 0 // 0:上, 1:右, 2:下, 3:左
};

function puyoReset() {
    puyoPlayer.pos = {x: 4, y: 1};
    puyoPlayer.colors = [Math.floor(Math.random()*4)+1, Math.floor(Math.random()*4)+1];
    puyoPlayer.rot = 0;
    if (puyoCollide()) {
        puyoBoard.forEach(row => row.fill(0));
        score = 0;
    }
}

function puyoCollide() {
    const {x, y} = puyoPlayer.pos;
    const {rot} = puyoPlayer;
    const rx = [0, 1, 0, -1][rot];
    const ry = [-1, 0, 1, 0][rot];
    
    if (x < 0 || x >= COLS || y >= ROWS || puyoBoard[y][x] !== 0) return true;
    const cx = x + rx, cy = y + ry;
    if (cx < 0 || cx >= COLS || cy >= ROWS || (puyoBoard[cy] && puyoBoard[cy][cx] !== 0)) return true;
    return false;
}

function puyoMerge() {
    const {x, y} = puyoPlayer.pos;
    const rx = [0, 1, 0, -1][puyoPlayer.rot];
    const ry = [-1, 0, 1, 0][puyoPlayer.rot];
    puyoBoard[y][x] = puyoPlayer.colors[0];
    if (puyoBoard[y + ry]) puyoBoard[y + ry][x + rx] = puyoPlayer.colors[1];
    puyoApplyGravity();
    puyoCheckChains();
}

function puyoApplyGravity() {
    for (let x = 0; x < COLS; x++) {
        for (let y = ROWS - 1; y > 0; y--) {
            if (puyoBoard[y][x] === 0) {
                for (let nextY = y - 1; nextY >= 0; nextY--) {
                    if (puyoBoard[nextY][x] !== 0) {
                        puyoBoard[y][x] = puyoBoard[nextY][x];
                        puyoBoard[nextY][x] = 0;
                        break;
                    }
                }
            }
        }
    }
}

function puyoCheckChains() {
    let matched = [];
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            if (puyoBoard[y][x] === 0) continue;
            let group = [];
            findPuyoGroup(x, y, puyoBoard[y][x], group);
            if (group.length >= 4) matched.push(...group);
        }
    }

    if (matched.length > 0) {
        matched.forEach(p => {
            spawnExplosion(300 + p.x * BLOCK_SIZE + 15, p.y * BLOCK_SIZE + 15, PUYO_COLORS[puyoBoard[p.y][p.x]]);
            puyoBoard[p.y][p.x] = 0;
        });
        score += matched.length * 50;
        setTimeout(() => {
            puyoApplyGravity();
            puyoCheckChains();
        }, 150);
    }
    scoreElement.innerText = score;
}

function findPuyoGroup(x, y, color, group) {
    if (x < 0 || x >= COLS || y < 0 || y >= ROWS || puyoBoard[y][x] !== color) return;
    if (group.some(p => p.x === x && p.y === y)) return;
    group.push({x, y});
    findPuyoGroup(x + 1, y, color, group);
    findPuyoGroup(x - 1, y, color, group);
    findPuyoGroup(x, y + 1, color, group);
    findPuyoGroup(x, y - 1, color, group);
}

/**
 * --- 演出 & 描画 ---
 */
function spawnExplosion(x, y, color) {
    for (let i = 0; i < 15; i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            life: 30,
            color
        });
    }
}

function draw() {
    // クリア
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // グリッド線（演出）
    ctx.strokeStyle = '#222';
    for(let i=0; i<CANVAS_WIDTH; i+=BLOCK_SIZE) {
        ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,600); ctx.stroke();
    }

    // テトリス描画
    drawMatrix(tetrisBoard, {x: 0, y: 0}, TETRIS_COLORS);
    drawMatrix(tetrisPlayer.matrix, tetrisPlayer.pos, TETRIS_COLORS);

    // ぷよ描画
    drawPuyoBoard();
    drawPuyoActive();

    // 境界線
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#444';
    ctx.beginPath(); ctx.moveTo(300, 0); ctx.lineTo(300, 600); ctx.stroke();

    // パーティクル
    particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.life--;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.fillRect(p.x, p.y, 4, 4);
        if (p.life <= 0) particles.splice(i, 1);
    });
    ctx.globalAlpha = 1;
}

function drawMatrix(matrix, offset, colors) {
    matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                const px = (x + offset.x) * BLOCK_SIZE;
                const py = (y + offset.y) * BLOCK_SIZE;
                ctx.fillStyle = colors[value];
                ctx.fillRect(px + 1, py + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
                // 光沢
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(px + 3, py + 3, BLOCK_SIZE - 20, 5);
            }
        });
    });
}

function drawPuyoBoard() {
    puyoBoard.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) drawPuyoBall(300 + x * BLOCK_SIZE, y * BLOCK_SIZE, PUYO_COLORS[value]);
        });
    });
}

function drawPuyoBall(x, y, color) {
    ctx.save();
    ctx.translate(x + BLOCK_SIZE/2, y + BLOCK_SIZE/2);
    
    // 本体
    ctx.beginPath();
    ctx.arc(0, 0, BLOCK_SIZE/2 - 2, 0, Math.PI*2);
    ctx.fillStyle = color;
    ctx.fill();
    
    // 目
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(-5, -2, 4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(5, -2, 4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(-5, -2, 2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(5, -2, 2, 0, Math.PI*2); ctx.fill();
    
    ctx.restore();
}

function drawPuyoActive() {
    const {x, y} = puyoPlayer.pos;
    const rx = [0, 1, 0, -1][puyoPlayer.rot];
    const ry = [-1, 0, 1, 0][puyoPlayer.rot];
    drawPuyoBall(300 + x * BLOCK_SIZE, y * BLOCK_SIZE, PUYO_COLORS[puyoPlayer.colors[0]]);
    drawPuyoBall(300 + (x + rx) * BLOCK_SIZE, (y + ry) * BLOCK_SIZE, PUYO_COLORS[puyoPlayer.colors[1]]);
}

/**
 * --- メインループ & 入力 ---
 */
let dropCounter = 0;
let lastTime = 0;

function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;

    if (dropCounter > 1000) {
        // テトリス落下
        tetrisPlayer.pos.y++;
        if (tetrisCollide()) {
            tetrisPlayer.pos.y--;
            tetrisMerge();
            tetrisReset();
            tetrisSweep();
        }
        // ぷよ落下
        puyoPlayer.pos.y++;
        if (puyoCollide()) {
            puyoPlayer.pos.y--;
            puyoMerge();
            puyoReset();
        }
        dropCounter = 0;
    }

    draw();
    requestAnimationFrame(update);
}

document.addEventListener('keydown', e => {
    // Tetris (Arrows)
    if (e.keyCode === 37) { tetrisPlayer.pos.x--; if(tetrisCollide()) tetrisPlayer.pos.x++; }
    if (e.keyCode === 39) { tetrisPlayer.pos.x++; if(tetrisCollide()) tetrisPlayer.pos.x--; }
    if (e.keyCode === 40) { tetrisPlayer.pos.y++; if(tetrisCollide()) tetrisPlayer.pos.y--; }
    if (e.keyCode === 38) { 
        const old = tetrisPlayer.matrix;
        tetrisRotate(1);
        if(tetrisCollide()) tetrisPlayer.matrix = old;
    }

    // Puyo (WASD)
    if (e.key === 'a' || e.key === 'A') { puyoPlayer.pos.x--; if(puyoCollide()) puyoPlayer.pos.x++; }
    if (e.key === 'd' || e.key === 'D') { puyoPlayer.pos.x++; if(puyoCollide()) puyoPlayer.pos.x--; }
    if (e.key === 's' || e.key === 'S') { puyoPlayer.pos.y++; if(puyoCollide()) puyoPlayer.pos.y--; }
    if (e.key === 'w' || e.key === 'W') { 
        const oldRot = puyoPlayer.rot;
        puyoPlayer.rot = (puyoPlayer.rot + 1) % 4;
        if(puyoCollide()) puyoPlayer.rot = oldRot;
    }
});

// 初期化
tetrisReset();
puyoReset();
update();

</script>
</body>
</html>
